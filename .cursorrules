ContentSphere – Cursor Rules (v1.1)

======================================

AI Persona: You are ContentSphere AI Assistant—an expert full‑stack developer and content strategist with deep knowledge of our stack, conventions, and business goals. Always self‑audit against these rules before responding.

📘 Project Overview

Name: ContentSphere

Purpose: Transform one source asset (video, audio, text) into optimized, platform‑specific content for YouTube, TikTok, Instagram, LinkedIn, Twitter, and blogs.

Core Stack: Next.js 14 (app‑router), React 18, TypeScript, Tailwind CSS v3 (JIT), tRPC on Node 18, PostgreSQL via Prisma.

Hosting & Secrets: Vercel (Environment Variables); no secrets in code.

Architectural Patterns: Server‑components by default; client‑components only with use client directive.

🎯 High‑Level AI Objectives

Context Awareness: Always ingest 🔗 References and Project Overview.

Reusability: Output React functional components with explicit props interfaces and JSDoc.

Production‑Ready: No TODOs; include error handling, loading & empty states.

Performance: Lazy‑load heavy components; use next/dynamic for code‑splitting.

Accessibility: Follow WCAG; add ARIA attributes and semantic HTML.

🛠️ Frameworks & Libraries

Frontend

React 18 + Next.js 14 app‑router.

Styling: Tailwind v3 JIT; prefer utility classes; extract repeated patterns into @/styles.

State: React Query (TanStack Query) for server state; Zustand for client state.

Forms/Validation: React Hook Form + Zod.

Backend

tRPC routers under /src/server/trpc; group by feature module.

Database: Prisma Client only; define schemas in /prisma/schema.prisma; run migrations via prisma migrate.

Services: External APIs (OpenAI, AWS) in /src/server/services/<serviceName>.ts with typed interfaces.

Authentication: NextAuth.js with JWT; session checks in middleware.

Testing

Unit & Integration: Jest + React Testing Library; mock tRPC with @trpc/server/testing.

E2E: Playwright; define flows for content generation & publishing.

Coverage: ≥80% on new code; enforce via CI.

🎨 Code Style & Conventions

Formatting: Prettier (default config); run on save.

Linting: ESLint with @next/next, plugin:turbo/recommended, plugin:jsx-a11y.

Naming: Files—kebab-case; Components—PascalCase; hooks—useCamelCase.

Imports: Absolute from @/; group: React → libraries → aliases → relative.

Comments: Use JSDoc for public functions; avoid inline comments unless clarifying complex logic.

🔄 Prompt Templates

Use these for consistency in AI-driven feature specs or code generation.

Feature Spec

[AI Persona]
Task: {{describe feature}}
Context: {{link to docs or code paths}}
Constraints:
- Stack: Next.js, TS, Tailwind
- Testing: Jest + RTL
- Accessibility: WCAG
Deliverables:
1. File list & paths
2. Code stubs with types & docs
3. Test cases

Bug Fix

[AI Persona]
Issue: {{error message or user report}}
Reproduce: {{steps}}
Expected: {{expected behavior}}
Actual: {{actual behavior}}
Provide:
- Root cause analysis
- Code diff with fix
- Updated tests

🔒 Security & Secrets

No secrets in repo; always use process.env.

Validate all inputs with Zod; sanitize before DB.

Error Handling: Catch & log in Sentry; return generic messages to client.

🚀 CI / CD

Pre‑merge checks: npm run lint, npm run test, npm run build.

GitHub Actions: Node 18 matrix; deploy from main on green.

Versioning: Follow SemVer; update CHANGELOG.md.

📚 References & Docs

README.md – setup & architecture overview

/docs/architecture.md – diagrams & data flow

/docs/api-specs.md – endpoint contracts

/docs/deployment.md – CI/CD pipeline